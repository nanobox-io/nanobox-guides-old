<!DOCTYPE html>
<html>
  <head>
    <head>
      <meta charset='utf-8'>
      <!-- Always force latest IE rendering engine or request Chrome Frame -->
      <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
      <meta content='width=device-width, initial-scale=1.0' name='viewport'>
      <!-- Typekit -->
      <script src='https://use.typekit.net/cqd5kth.js'></script>
      <script>
        try{Typekit.load({ async: true });}catch(e){}
      </script>
      <!-- Google Analytics -->
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        
        ga('create', 'UA-760419-20', 'auto');
        ga('send', 'pageview');
      </script>
    </head>
    <title>Configuring Redis - Redis on Nanobox</title>
    <link href="/stylesheets/styles.css" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
    <link href="/redis/project-styles.css" rel="stylesheet" type="text/css" />
    <link href='/redis/img/favicon.png' rel='icon' type='image/png'>
  </head>
  <body class='guide'>
    <div id='header'>
      <a href='/redis/' id='logo-link'>
        <img src="/images/icons/redis.svg" />
        <div class='project-title'>
          <p class='name'>Redis</p>
          <p class='nb'>on Nanobox</p>
        </div>
      </a>
      <a href='/' id='nbg-logo-link'>
        <span class='nbg-logo'>
          <svg enable-background='new 0 0 38 32' id='nbg-logo' space='preserve' version='1.1' viewbox='0 0 38 32' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
            <polyline fill='none' points='&#x000A;			13.6,13 1.5,19 4.8,24.1 8.2,22.4 11.7,27.5 15.1,25.9 18.5,31 36.1,22.2 32.7,17.1 29.4,18.8 25.8,13.6 22.6,15.2 		' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='1.5' stroke='#ffffff'></polyline>
            <line fill='none' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='1.5' stroke='#ffffff' x1='15.2' x2='29.3' y1='25.9' y2='18.8'></line>
            <line fill='none' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='1.5' stroke='#ffffff' x1='8.2' x2='16.9' y1='22.4' y2='18.1'></line>
            <path d='&#x000A;		M25.1,8.2c0,5.6-6.3,11.9-6.3,11.9s-6.3-6.3-6.3-11.9c0-3.5,2.8-6.3,6.3-6.3S25.1,4.7,25.1,8.2z' fill='none' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='1.5' stroke='#ffffff'></path>
            <circle cx='18.8' cy='8.2' fill='none' r='2.6' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='1.5' stroke='#ffffff'></circle>
          </svg>
        </span>
        <span class='nbg-text'>Nanobox Guides</span>
      </a>
    </div>
    <div id='page-body'>
      <div class='wrapper'>
        <div id='left-nav'>
          <div id='contents-btn'>
            <div class='lines'></div>
          </div>
          
          <ul class='closed' id='contents'>
            <li>
              <span>
                <svg enable-background='new 0 0 14 14' space='preserve' version='1.1' viewbox='0 0 14 14' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
                  <g class='nav-bullet'>
                    <rect x='4.5' y='4.5'></rect>
                  </g>
                </svg>
              </span>
              <a href="/redis/">Getting Started</a>
            </li>
            <li>
              <span>
                <svg enable-background='new 0 0 14 14' space='preserve' version='1.1' viewbox='0 0 14 14' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
                  <g class='nav-bullet'>
                    <rect x='4.5' y='4.5'></rect>
                  </g>
                </svg>
              </span>
              <a href="/redis/connect/">Connecting to Redis</a>
            </li>
            <li class='active'>
              <span>
                <svg enable-background='new 0 0 14 14' space='preserve' version='1.1' viewbox='0 0 14 14' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
                  <g class='nav-bullet'>
                    <rect x='4.5' y='4.5'></rect>
                  </g>
                </svg>
              </span>
              <a href="/redis/configure/">Configuring Redis</a>
            </li>
            <li>
              <span>
                <svg enable-background='new 0 0 14 14' space='preserve' version='1.1' viewbox='0 0 14 14' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
                  <g class='nav-bullet'>
                    <rect x='4.5' y='4.5'></rect>
                  </g>
                </svg>
              </span>
              <a href="/redis/manage/">Managing Data</a>
            </li>
          </ul>
        </div>
        <div class='guide-content'>
          <h1>Configuring Redis</h1>
          <p>Redis components are configured in your <code>boxfile.yml</code>. All available configuration options are outlined below.</p>
          
          <h3 id="important-notes-about-configuration-changes">Important Notes About Configuration Changes</h3>
          
          <p>Whenever configuration changes are made to your Redis boxfile.yml config, in order to apply those changes, Nanobox must provision a new Redis node.</p>
          
          <h4 id="changes-in-dev-amp-sim">Changes in Dev &amp; Sim</h4>
          
          <p>When working in <a href="https://docs.nanobox.io/local-dev/dev-sim/">dev and sim</a>, this will replace the existing node, wiping all data. If you&#39;re using Redis as a persistent datastore, data will need to be re-seeded.</p>
          
          <h4 id="changes-to-a-production-database">Changes to a Production Database</h4>
          
          <p>When config changes are made to a production database, a new node is provisioned and data is migrated. There will be slight downtime as data is synced between the old and new node(s), but the process is designed to minimize this as much as possible. More information is available in the <a href="https://docs.nanobox.io/data-management/data-migrations-scaling/">Data Migrations During Scaling &amp; Repairs </a> doc.</p>
          
          <h4 id="overview-of-redis-boxfile-yml-settings">Overview of Redis boxfile.yml Settings</h4>
          <pre class="highlight yaml"><code><span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">version</span><span class="pi">:</span> <span class="s">2.8</span>&#x000A;    <span class="na">tcp_keepalive</span><span class="pi">:</span> <span class="s">60</span>&#x000A;    <span class="na">databases</span><span class="pi">:</span> <span class="s">16</span>&#x000A;    <span class="na">stop_writes_on_bgsave_error</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;    <span class="na">slave_serve_stale_data</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;    <span class="na">slave_read_only</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;    <span class="na">repl_ping_slave_period</span><span class="pi">:</span> <span class="s">10</span>&#x000A;    <span class="na">repl_timeout</span><span class="pi">:</span> <span class="s">60</span>&#x000A;    <span class="na">repl_disable_tcp_nodelay</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;    <span class="na">max_clients</span><span class="pi">:</span> <span class="s">1024</span>&#x000A;    <span class="na">maxmemory_policy</span><span class="pi">:</span> <span class="s1">'</span><span class="s">volatile-lru'</span>&#x000A;    <span class="na">maxmemory_samples</span><span class="pi">:</span> <span class="s">3</span>&#x000A;    <span class="na">appendonly</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;    <span class="na">appendfsync</span><span class="pi">:</span> <span class="s1">'</span><span class="s">everysec'</span>&#x000A;    <span class="na">no_appendfsync_on_rewrite</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;    <span class="na">auto_aof_rewrite_percentage</span><span class="pi">:</span> <span class="s">100</span>&#x000A;    <span class="na">auto_aof_rewrite_min_size</span><span class="pi">:</span> <span class="s1">'</span><span class="s">64m'</span>&#x000A;    <span class="na">lua_time_limit</span><span class="pi">:</span> <span class="s">5000</span>&#x000A;    <span class="na">slowlog_log_slower_than</span><span class="pi">:</span> <span class="s">0</span>&#x000A;    <span class="na">slowlog_max_len</span><span class="pi">:</span> <span class="s">128</span>&#x000A;&#x000A;    <span class="c1"># Advanced Configs</span>&#x000A;    <span class="na">hash_max_ziplist_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;    <span class="na">hash_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;    <span class="na">list_max_ziplist_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;    <span class="na">list_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;    <span class="na">set_max_intset_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;    <span class="na">zset_max_ziplist_entries</span><span class="pi">:</span> <span class="s">12</span>&#x000A;    <span class="na">zset_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;    <span class="na">activerehashing</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;    <span class="na">hz</span><span class="pi">:</span> <span class="s">10</span>&#x000A;    <span class="na">aof_rewrite_incremental_fsync</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h6 id="quick-links">Quick Links</h6>
          
          <p><a href="#version">version</a><br>
          <a href="#tcp-keepalive">tcp_keepalive</a><br>
          <a href="#databases">databases</a><br>
          <a href="#stop-writes-on-bgsave-error">stop_writes_on_bgsave_error</a><br>
          <a href="#slave-serve-stale-data">slave_serve_stale_data</a><br>
          <a href="#slave-read-only">slave_read_only</a><br>
          <a href="#repl-ping-slave-period">repl_ping_slave_period</a><br>
          <a href="#repl-timeout">repl_timeout</a><br>
          <a href="#repl-disable-tcp-nodelay">repl_disable_tcp_nodelay</a><br>
          <a href="#max-clients">max_clients</a><br>
          <a href="#maxmemory-policy">maxmemory_policy</a><br>
          <a href="#maxmemory-samples">maxmemory_samples</a><br>
          <a href="#appendonly">appendonly</a><br>
          <a href="#appendfsync">appendfsync</a><br>
          <a href="#no-appendfsync-on-rewrite">no_appendfsync_on_rewrite</a><br>
          <a href="#auto-aof-rewrite-percentage">auto_aof_rewrite_percentage</a><br>
          <a href="#auto-aof-rewrite-min-size">auto_aof_rewrite_min_size</a><br>
          <a href="#lua-time-limit">lua_time_limit</a><br>
          <a href="#slowlog-log-slower-than">slowlog_log_slower_than</a><br>
          <a href="#slowlog-max-length">slowlog_max_len</a>  </p>
          
          <p>Advanced Configs<br>
          <a href="#hash-max-ziplist-entries">hash_max_ziplist_entries</a><br>
          <a href="#hash-max-ziplist-value">hash_max_ziplist_value</a><br>
          <a href="#list-max-ziplist-entries">list_max_ziplist_entries</a><br>
          <a href="#list-max-ziplist-value">list_max_ziplist_value</a><br>
          <a href="#set-max-intset-entries">set_max_intset_entries</a><br>
          <a href="#zset-max-ziplist-entries">zset_max_ziplist_entries</a><br>
          <a href="#zset-max-ziplist-values">zset_max_ziplist_value</a><br>
          <a href="#activerehashing">activerehashing</a><br>
          <a href="#hz">hz</a><br>
          <a href="#aof-rewrite-incremental-fsync">aof_rewrite_incremental_fsync</a></p>
          
          <h3 id="version">Version</h3>
          
          <p>When configuring a Redis service in your Boxfile, can specify which version of Redis to use. The following version(s) are available:</p>
          
          <ul>
          <li>2.6</li>
          <li>2.8</li>
          <li>3.0</li>
          </ul>
          
          <p><strong>Note:</strong> Due to version compatibility constraints, Redis versions cannot be changed after the service is created. To use a different version, you&#39;ll have to create a new Redis service.</p>
          
          <h4 id="version">version</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">version</span><span class="pi">:</span> <span class="s">3.0</span>&#x000A;</code></pre>
          <h3 id="tcp-keepalive">TCP Keepalive</h3>
          
          <p>If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication. This is useful for two reasons:</p>
          
          <ol>
          <li>Detect dead peers.</li>
          <li>Take the connection alive from the point of view of network equipment in the middle.</li>
          </ol>
          
          <h4 id="tcp_keepalive">tcp_keepalive</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">tcp_keepalive</span><span class="pi">:</span> <span class="s">60</span>&#x000A;</code></pre>
          <h3 id="databases">Databases</h3>
          
          <p>Sets the number of databases.</p>
          
          <h4 id="databases">databases</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">databases</span><span class="pi">:</span> <span class="s">16</span>&#x000A;</code></pre>
          <h3 id="stop-writes-on-bgsave-error">Stop Writes on BGSave Error</h3>
          
          <p>By default Redis will stop accepting writes if RDB snapshots are enabled (at least one save point) and the latest background save failed. This will make the user aware (in an hard way) that data is not persisting on disk properly, otherwise chances are that no one will notice and some disaster will happen.</p>
          
          <p>If the background saving process will start working again Redis will automatically allow writes again.</p>
          
          <p>However if you have setup your proper monitoring of the Redis server and persistence, you may want to disable this feature so that Redis will continue to work as usually even if there are problems with disk, permissions, and so forth.</p>
          
          <h4 id="stop_writes_on_bgsave_error">stop_writes_on_bgsave_error</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">stop_writes_on_bgsave_error</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h3 id="slave-serve-stale-data">Slave Serve Stale Data</h3>
          
          <p>When a slave loses its connection with the master, or when the replication is still in progress, the slave can act in two different ways:</p>
          
          <ol>
          <li><p>If slave-serve-stale-data is set to &#39;yes&#39; the slave will still reply to client requests, possibly with out of date data, or the data set may just be empty if this is the first synchronization.</p></li>
          <li><p>If slave-serve-stale-data is set to &#39;no&#39; the slave will reply with an error &quot;SYNC with master in progress&quot; to all the kind of commands but to INFO and SLAVEOF.</p></li>
          </ol>
          
          <h4 id="slave_serve_stale_data">slave_serve_stale_data</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">slave_serve_stale_data</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h3 id="slave-read-only">Slave Read-Only</h3>
          
          <p>You can configure a slave instance to accept writes or not. Writing against a slave instance may be useful to store some ephemeral data (because data written on a slave will be easily deleted after resync with the master) but may also cause problems if clients are writing to it because of a misconfiguration.</p>
          
          <h4 id="slave_read_only">slave_read_only</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">slave_read_only</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h3 id="repl-ping-slave-period">Repl Ping Slave Period</h3>
          
          <p>Slaves send PINGs to server in a predefined interval. It&#39;s possible to change this interval.</p>
          
          <h4 id="repl_ping_slave_period">repl_ping_slave_period</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">repl_ping_slave_period</span><span class="pi">:</span> <span class="s">10</span>&#x000A;</code></pre>
          <h3 id="repl-timeout">Repl Timeout</h3>
          
          <p>The following option sets a timeout for both Bulk transfer I/O timeout and master data or ping response timeout. The default value is 60 seconds. It is important to make sure that this value is greater than the value specified for <a href="#repl-ping-slave-period"><code>repl_ping_slave_period</code></a> otherwise a timeout will be detected every time there is low traffic between the master and the slave.</p>
          
          <h4 id="repl_timeout">repl_timeout</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">repl_timeout</span><span class="pi">:</span> <span class="s">60</span>&#x000A;</code></pre>
          <h3 id="repl-disable-tcp-nodelay">Repl Disable TCP NoDelay</h3>
          
          <p>Toggles TCP_NODELAY on the slave socket after SYNC. If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and less bandwidth to send data to slaves. But this can add a delay for the data to appear on the slave side. If you select &quot;no&quot; the delay for data to appear on the slave side will be reduced but more bandwidth will be used for replication.</p>
          
          <h4 id="repl_disable_tcp_nodelay">repl_disable_tcp_nodelay</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">repl_disable_tcp_nodelay</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;</code></pre>
          <h3 id="max-clients">Max Clients</h3>
          
          <p>Set the max number of clients connected at the same time. Once the limit is reached Redis will close all the new connections sending an error &#39;max number of clients reached&#39;.</p>
          
          <h4 id="max_clients">max_clients</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">max_clients</span><span class="pi">:</span> <span class="s">1024</span>&#x000A;</code></pre>
          <h3 id="maxmemory-policy">MaxMemory Policy</h3>
          
          <p>Defines how Redis will select what to remove when maxmemory is reached. You can select among five behaviors:</p>
          
          <ul>
          <li><strong>volatile-lru</strong> - remove the key with an expire set using an LRU algorithm</li>
          <li><strong>allkeys-lru</strong> - remove any key accordingly to the LRU algorithm</li>
          <li><strong>volatile-random</strong> - remove a random key with an expire set</li>
          <li><strong>allkeys-random</strong> - remove a random key, any key</li>
          <li><strong>volatile-ttl</strong> - remove the key with the nearest expire time (minor TTL)</li>
          <li><strong>noeviction</strong> - don&#39;t expire at all, just return an error on write operations</li>
          </ul>
          
          <h4 id="maxmemory_policy">maxmemory_policy</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">maxmemory_policy</span><span class="pi">:</span> <span class="s1">'</span><span class="s">volatile-lru'</span>&#x000A;</code></pre>
          <h3 id="maxmemory-samples">MaxMemory Samples</h3>
          
          <p>LRU and minimal TTL algorithms are not precise algorithms but approximated algorithms (in order to save memory), so you can select as well the sample size to check. For instance for default Redis will check three keys and pick the one that was used less recently, you can change the sample size using the following configuration directive.</p>
          
          <h4 id="maxmemory_samples">maxmemory_samples</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">maxmemory_samples</span><span class="pi">:</span> <span class="s">3</span>&#x000A;</code></pre>
          <h3 id="appendonly">AppendOnly</h3>
          
          <p>By default Redis asynchronously dumps the dataset on disk. This mode is good enough in many applications, but an issue with the Redis process or a power outage may result into a few minutes of writes lost (depending on the configured save points).</p>
          
          <p>The Append Only File is an alternative persistence mode that provides much better durability. For instance, using the default data <a href="#appendfsync">fsync policy</a>, Redis can lose just one second of writes in a dramatic event like a server power outage, or a single write if something wrong with the Redis process itself happens, but the operating system is still running correctly.</p>
          
          <p>AOF and RDB persistence can be enabled at the same time without problems. If the AOF is enabled on startup Redis will load the AOF, that is the file with the better durability guarantees. Please check <a href="http://redis.io/topics/persistence">Redis Persistence Documentation</a> for more information.</p>
          
          <h4 id="appendonly">appendonly</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">appendonly</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;</code></pre>
          <h3 id="appendfsync">AppendFSync</h3>
          
          <p>The fsync() call tells the Operating System to actually write data on disk instead to wait for more data in the output buffer. Redis supports three different modes:</p>
          
          <ul>
          <li><strong>no</strong> - don&#39;t fsync, just let the OS flush the data when it wants. Faster.</li>
          <li><strong>always</strong> - fsync after every write to the append only log . Slow, Safest.</li>
          <li><strong>everysec</strong> - fsync only one time every second. Compromise.</li>
          </ul>
          
          <p>The default is &quot;everysec&quot;, as that&#39;s usually the right compromise between speed and data safety. It&#39;s up to you to understand if you can relax this to &quot;no&quot; that will let the operating system flush the output buffer when it wants, for better performances (but if you can live with the idea of some data loss consider the default persistence mode that&#39;s snapshotting), or on the contrary, use &quot;always&quot; that&#39;s very slow but a bit safer than everysec.</p>
          
          <p>More details in <a href="http://antirez.com/post/redis-persistence-demystified.html">Redis Persistence Demistified</a>.</p>
          
          <p>If unsure, use &quot;everysec&quot;.</p>
          
          <h4 id="appendfsync">appendfsync</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">appendfsync</span><span class="pi">:</span> <span class="s1">'</span><span class="s">everysec'</span>&#x000A;</code></pre>
          <h3 id="no-appendfsync-on-rewrite">No AppendFSync on Rewrite</h3>
          
          <p>When the <a href="#appendfsync">AOF fsync</a> policy is set to always or everysec, and a background saving process (a background save or AOF log background rewriting) is performing a lot of I/O against the disk, Redis may block too long on the fsync() call. Note that there is no fix for this currently, as even performing fsync in a different thread will block the synchronous write(2) call.</p>
          
          <p>In order to mitigate this problem it&#39;s possible to use the following option that will prevent fsync() from being called in the main process while a BGSAVE or BGREWRITEAOF is in progress.</p>
          
          <p>This means that while another child is saving, the durability of Redis is the same as <code>appendfsync: &#39;none&#39;</code>. In practical terms, this means that it is possible to lose up to 30 seconds of log in the worst scenario.</p>
          
          <p>If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as &quot;no&quot; that is the safest pick from the point of view of durability.</p>
          
          <h4 id="no_appendfsync_on_rewrite">no_appendfsync_on_rewrite</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">no_appendfsync_on_rewrite</span><span class="pi">:</span> <span class="s1">'</span><span class="s">no'</span>&#x000A;</code></pre>
          <h3 id="auto-aof-rewrite-percentage">Auto AOF Rewrite Percentage</h3>
          
          <p>Redis is able to automatically rewrite the log file implicitly calling BGREWRITEAOF when the AOF log size grows by the specified percentage. Redis remembers the size of the AOF file after the latest rewrite. This base size is compared to the current size. If the current size is bigger than the specified percentage, the rewrite is triggered. Also you need to <a href="#auto-aof-rewrite-percentage">specify a minimal size for the AOF file to be rewritten</a>, this is useful to avoid rewriting the AOF file even if the percentage increase is reached but it is still pretty small.</p>
          
          <p>Specify a percentage of zero in order to disable the automatic AOF rewrite feature.</p>
          
          <h4 id="auto_aof_rewrite_percentage">auto_aof_rewrite_percentage</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">auto_aof_rewrite_percentage</span><span class="pi">:</span> <span class="s">100</span>&#x000A;</code></pre>
          <h3 id="auto-aof-rewrite-min-size">Auto AOF Rewrite Min Size</h3>
          
          <p>Specifies the minimal size for the AOF file to be rewritten.</p>
          
          <h4 id="auto_aof_rewrite_min_size">auto_aof_rewrite_min_size</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">auto_aof_rewrite_min_size</span><span class="pi">:</span> <span class="s1">'</span><span class="s">64m'</span>&#x000A;</code></pre>
          <h3 id="lua-time-limit">Lua Time Limit</h3>
          
          <p>Set the Max execution time of a Lua script in milliseconds.</p>
          
          <p>If the maximum execution time is reached Redis will log that a script is still in execution after the maximum allowed time and will start to reply to queries with an error.</p>
          
          <p>When a long running script exceed the maximum execution time only the SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be used to stop a script that did not yet called write commands. The second is the only way to shut down the server in the case a write commands was already issue by the script but the user don&#39;t want to wait for the natural termination of the script.</p>
          
          <p>Set it to 0 or a negative value for unlimited execution without warnings.</p>
          
          <h4 id="lua_time_limit">lua_time_limit</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">lua_time_limit</span><span class="pi">:</span> <span class="s">5000</span>&#x000A;</code></pre>
          <h3 id="slowlog-log-slower-than">SlowLog Log Slower Than</h3>
          
          <p>This tells Redis what is the execution time, in microseconds, to exceed in order for the command to get logged to the <a href="http://redis.io/commands/slowlog">Redis Slow Log</a>.</p>
          
          <h4 id="slowlog_log_slower_than">slowlog_log_slower_than</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">slowlog_log_slower_than</span><span class="pi">:</span>&#x000A;</code></pre>
          <h3 id="slowlog-max-length">SlowLog Max Length</h3>
          
          <p>This parameter sets the length of the slow log. When a new command is logged the oldest one is removed from the queue of logged commands.</p>
          
          <h4 id="slowlog_max_len">slowlog_max_len</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">slowlog_max_len</span><span class="pi">:</span> <span class="s">128</span>&#x000A;</code></pre>
          <h2 id="advanced-redis-config">Advanced Redis Config</h2>
          
          <h3 id="hash-max-ziplist-entries">Hash Max Ziplist Entries</h3>
          
          <p>Sets the max number of hash entries before they are encrypted to save space.</p>
          
          <h4 id="hash_max_ziplist_entries">hash_max_ziplist_entries</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">hash_max_ziplist_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;</code></pre>
          <h3 id="hash-max-ziplist-value">Hash Max Ziplist Value</h3>
          
          <p>Sets the max value of hash entries before they are encrypted to save space.</p>
          
          <h4 id="hash_max_ziplist_value">hash_max_ziplist_value</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">hash_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;</code></pre>
          <h3 id="list-max-ziplist-entries">List Max Ziplist Entries</h3>
          
          <p>Sets the max number of list entries before they are encrypted to save space.</p>
          
          <h4 id="list_max_ziplist_entrie">list_max_ziplist_entrie</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">list_max_ziplist_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;</code></pre>
          <h3 id="list-max-ziplist-value">List Max Ziplist Value</h3>
          
          <p>Sets the max value of list entries before they are encrypted to save space.</p>
          
          <h4 id="list_max_ziplist_value">list_max_ziplist_value</h4>
          <pre class="highlight yaml"><code><span class="c1"># default settings</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">list_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;</code></pre>
          <h3 id="set-max-intset-entries">Set Max IntSet Entries</h3>
          
          <p>Sets have a special encoding in just one case: when a set is composed of just strings that happens to be integers in radix 10 in the range of 64 bit signed integers. The following configuration setting sets the limit in the size of the set in order to use this special memory saving encoding.</p>
          
          <h4 id="set_max_intset_entries">set_max_intset_entries</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">set_max_intset_entries</span><span class="pi">:</span> <span class="s">512</span>&#x000A;</code></pre>
          <h3 id="zset-max-ziplist-entries">ZSet Max Ziplist Entries</h3>
          
          <p>Sets the maximum number of entries before a sorted set is encoded to save space.</p>
          
          <h4 id="zset_max_ziplist_entries">zset_max_ziplist_entries</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">zset_max_ziplist_entries</span><span class="pi">:</span> <span class="s">12</span>    &#x000A;</code></pre>
          <h3 id="zset-max-ziplist-values">ZSet Max Ziplist Values</h3>
          
          <p>Sets the maximum value of entries before a sorted set is encoded to save space.</p>
          
          <h4 id="zset_max_ziplist_value">zset_max_ziplist_value</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">zset_max_ziplist_value</span><span class="pi">:</span> <span class="s">64</span>&#x000A;</code></pre>
          <h3 id="activerehashing">ActiveRehashing</h3>
          
          <p>Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in order to help rehashing the main Redis hash table (the one mapping top-level keys to values). The hash table implementation Redis uses (see dict.c) performs a lazy rehashing: the more operation you run into an hash table that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the server is idle the rehashing is never complete and some more memory is used by the hash table.</p>
          
          <p>The default is to use this millisecond 10 times every second in order to active rehashing the main dictionaries, freeing memory when possible.</p>
          
          <p>If unsure: use <code>activerehashing: &#39;no&#39;</code> if you have hard latency requirements and it is not a good thing in your environment that Redis can reply form time to time to queries with 2 milliseconds delay.</p>
          
          <p>Use <code>activerehashing: &#39;yes&#39;</code> if you don&#39;t have such hard requirements but want to free memory asap when possible.</p>
          
          <h4 id="activerehashing">activerehashing</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">activerehashing</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h3 id="hz">hz</h3>
          
          <p>Redis calls an internal function to perform many background tasks, like closing connections of clients in timeout, purging expired keys that are never requested, and so forth. Not all tasks are performed with the same frequency, but Redis checks for tasks to perform accordingly to the specified &quot;hz&quot; value.</p>
          
          <p>By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when Redis is idle, but at the same time will make Redis more responsive when there are many keys expiring at the same time, and timeouts may be handled with more precision.</p>
          
          <p>The range is between 1 and 500, however a value over 100 is usually not a good idea. Most users should use the default of 10 and raise this up to 100 only in environments where very low latency is required.</p>
          
          <h4 id="hz">hz</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">hz</span><span class="pi">:</span> <span class="s">10</span>&#x000A;</code></pre>
          <h3 id="aof-rewrite-incremental-fsync">AOF Rewrite Incremental FSync</h3>
          
          <p>When a child rewrites the AOF file, if the following option is enabled the file will be fsync-ed every 32 MB of data generated. This is useful in order to commit the file to the disk more incrementally and avoid big latency spikes.</p>
          
          <h4 id="aof_rewrite_incremental_fsync">aof_rewrite_incremental_fsync</h4>
          <pre class="highlight yaml"><code><span class="c1"># default setting</span>&#x000A;<span class="s">data.redis</span><span class="pi">:</span>&#x000A;  <span class="na">image</span><span class="pi">:</span> <span class="s">nanobox/redis</span>&#x000A;  <span class="na">config</span><span class="pi">:</span>&#x000A;    <span class="na">aof_rewrite_incremental_fsync</span><span class="pi">:</span> <span class="s1">'</span><span class="s">yes'</span>&#x000A;</code></pre>
          <h2 id="request-redis-boxfile-yml-configs">Request Redis boxfile.yml Configs</h2>
          
          <p>If there&#39;s a setting you&#39;d like to modify that isn&#39;t currently available, please let us know by creating a <a href="https://github.com/nanobox-io/nanobox-docker-redis/issues/new">new issue on this project</a>.</p>
          <div id='pagination'>
            <a name="Connecting to Redis" class="prev" href="/redis/connect/"><svg enable-background='new 0 0 23 23' id='left-arrow' space='preserve' version='1.1' viewbox='0 0 23 23' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
              <polyline fill='none' points='&#x000A;		10.6,20.4 1.7,11.5 10.6,2.6 	' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='2' stroke='#FFFFFF'></polyline>
              <line fill='none' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='2' stroke='#FFFFFF' x1='1.7' x2='21.7' y1='11.5' y2='11.5'></line>
            </svg>
            </a>
            <a name="Managing Data" class="next" href="/redis/manage/"><svg enable-background='new 0 0 23 23' id='right-arrow' space='preserve' version='1.1' viewbox='0 0 23 23' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
              <polyline fill='none' points='&#x000A;		12.7,2.6 21.7,11.5 12.7,20.4 	' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='2' stroke='#FFFFFF'></polyline>
              <line fill='none' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' stroke-width='2' stroke='#FFFFFF' x1='21.7' x2='1.7' y1='11.5' y2='11.5'></line>
            </svg>
            </a>
          </div>
        </div>
      </div>
    </div>
    <div id='footer'>
      <p class='made-with-love'>
        Made with
        <span>
          <svg enable-background='new 0 0 11 10' id='heart' space='preserve' version='1.1' viewbox='0 0 11 10' x='0px' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' y='0px'>
            <path d='M8.1,0.2C7,0.2,6,0.9,5.7,2c-0.3-1-1.3-1.8-2.4-1.8c-1.4,0-2.6,1.1-2.6,2.6c0,2.6,3,4.1,5,7c2-2.9,5-4.2,5-7&#x000A;	C10.7,1.3,9.5,0.2,8.1,0.2z'></path>
          </svg>
        </span>
        by <a href="https://nanobox.io">Nanobox</a>
      </p>
      <p class='license'>
        under the <a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL 2.0</a>
      </p>
      <p class='contribute'>
        Want to contribute to the guides? Checkout our <a href="/contribute/">contribution guidelines</a>.
      </p>
    </div>
  </body>
</html>
